Index: Generator/generator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <map>\n#include <math.h>\n#include <limits>\nusing namespace std;\n\n\nvoid create_plane (float length, float width, string file_name) {\n  // Create and open a text file\n ofstream MyFile(file_name);\n\n // Write to the file\n MyFile << \"Plane\\n\";\n MyFile << \"4\\n\";\n\n //Pontos do primeiro triangulo\n string point0 = to_string(length/2) + \" 0 \" + to_string(width/2) + \"\\n\";\n MyFile << point0;\n\n string point1 = to_string(length/2) + \" 0 \" + to_string(-width/2) + \"\\n\";\n MyFile << point1;\n\n string point2 = to_string(-length/2) + \" 0 \" + to_string(-width/2) + \"\\n\";\n MyFile << point2;\n\n string point3 = to_string(-length/2) + \" 0 \" + to_string(width/2) + \"\\n\";\n MyFile << point3;\n\n MyFile << \"0\\n\";\n MyFile << \"1\\n\";\n MyFile << \"2\\n\";\n MyFile << \"2\\n\";\n MyFile << \"3\\n\";\n MyFile << \"0\\n\";\n\n\n // Close the file\n MyFile.close();\n}\n\n\nint search_point(ostream& file, map<string,int>& m, string point, int index) {\n  auto it = m.find(point);\n  if ( it == m.end() ) {\n    m.insert({point,index});\n    file << point;\n    return index+1; //retorna o valor de index incrementado para indicar que houve inserção no mapa\n\n  } else {\n    // found\n    file << \"i\" + to_string(it->second) + \"\\n\";\n    return it->second; //retorna o valor de index que indica o indice em que estava o ponto\n  }\n\n}\n\nvoid create_box (float length, float width, float height, int divisions, string file_name) {\n    // Create and open a text file\n    ofstream MyFile(file_name);\n\n    // Write to the file\n    MyFile << \"Box\\n\";\n    MyFile << to_string(6 * divisions * divisions * 6) + \"\\n\"; //ns se esta bem\n\n    float translation_l = length / divisions;\n    float translation_w = width / divisions;\n    float translation_h = height / divisions;\n\n    map<string,int> m;\n\n    int index = 0;\n    std::cout.precision(std::numeric_limits<float>::digits10);\n\n    //Top and base\n    for (int k = 0; k < 2; k++) {\n        //Na primeira iteração y=height/2, para o topo, e na segunda y=-height/2, para a base.\n        float y = (height / 2) - (height * k);\n\n        for (int i = 0; i < divisions; i++) {\n            for (int j = 0; j < divisions; j++) {\n\n                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face\n                float move_x = (translation_l * j) + (-length / 2);\n                float move_z = (translation_w * i) + (-width / 2);\n                int index_point0;\n                int index_point2;\n\n                string point0 = to_string(move_x) + \" \" + to_string(y) + \" \" + to_string(move_z) + \"\\n\";\n                index_point0 = search_point(MyFile, m, point0, index);\n                if (index_point0 > index) { index = index_point0; index_point0--; }\n\n                string point1 =to_string(move_x) + \" \" + to_string(y) + \" \" + to_string(translation_w + move_z) + \"\\n\";\n                int res = search_point(MyFile,m,point1,index);\n                if (res > index) index = res;\n\n                string point2 = to_string(translation_l + move_x) + \" \" + to_string(y) + \" \" + to_string(translation_w + move_z) + \"\\n\";\n                index_point2 = search_point(MyFile, m, point2, index);\n                if (index_point2 > index) { index = index_point2; index_point2--; }\n\n                //Segundo triangulo\n                MyFile << \"i\" + to_string(index_point2) + \"\\n\";\n\n                string point3 = to_string(translation_l + move_x) + \" \" + to_string(y) + \" \" + to_string(move_z) + \"\\n\";\n                res = search_point(MyFile, m, point3, index);\n                if (res > index) index = res;\n\n                MyFile << \"i\" + to_string(index_point0) + \"\\n\";\n\n\n            }\n        }\n    }\n\n    //Front and back\n    for (int k = 0; k < 2; k++) {\n        //Na primeira iteração z=width/2, para a face da frente, e na segunda z=-width/2, para a face trás.\n        float z = (width / 2) - (width * k);\n\n        for (int i = 0; i < divisions; i++) {\n            for (int j = 0; j < divisions; j++) {\n                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face\n                float move_x = (translation_l * j) + (-length / 2);\n                float move_y = (height / 2) - (translation_h * i);\n                int index_point0;\n                int index_point2;\n\n                string point0 = to_string(move_x) + \" \" + to_string(move_y) + \" \" + to_string(z) + \"\\n\";\n                index_point0 = search_point(MyFile, m, point0, index);\n                if (index_point0 > index) { index = index_point0; index_point0--; }\n\n                string point1 = to_string(move_x) + \" \" + to_string(move_y - translation_h) + \" \" + to_string(z) + \"\\n\";\n                int res = search_point(MyFile,m,point1,index);\n                if (res > index) index = res;\n\n                string point2 = to_string(move_x + translation_l) + \" \" + to_string(move_y - translation_h) + \" \" + to_string(z) + \"\\n\";\n                index_point2 = search_point(MyFile, m, point2, index);\n                if (index_point2 > index) { index = index_point2; index_point2--; }\n\n                //Segundo triangulo\n                MyFile << \"i\" + to_string(index_point2) + \"\\n\";\n\n                string point3 = to_string(move_x + translation_l) + \" \" + to_string(move_y) + \" \" + to_string(z) + \"\\n\";\n                res = search_point(MyFile, m, point3, index);\n                if (res > index) index = res;\n\n                MyFile << \"i\" + to_string(index_point0) + \"\\n\";\n\n            }\n        }\n    }\n\n\n    //Right and left\n    for (int k = 0; k < 2; k++) {\n        //Na primeira iteração x=length/2, para a face da direita, e na segunda x=-length/2, para a face da esquerda.\n        float x = (length / 2) - (length * k);\n\n        for (int i = 0; i < divisions; i++) {\n            for (int j = 0; j < divisions; j++) {\n                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face\n                float move_y = (height / 2) - (translation_h * i);\n                float move_z = (width / 2) - (translation_w * j);\n                int index_point0;\n                int index_point2;\n\n                string point0 = to_string(x) + \" \" + to_string(move_y) + \" \" + to_string(move_z) + \"\\n\";\n                index_point0 = search_point(MyFile, m, point0, index);\n                if (index_point0 > index) { index = index_point0; index_point0--; }\n\n                string point1 = to_string(x) + \" \" + to_string(move_y - translation_h) + \" \" + to_string(move_z) + \"\\n\";\n                int res = search_point(MyFile,m,point1,index);\n                if (res > index) index = res;\n\n                string point2 = to_string(x) + \" \" + to_string(move_y - translation_h) + \" \" + to_string(move_z - translation_w) + \"\\n\";\n                index_point2 = search_point(MyFile, m, point2, index);\n                if (index_point2 > index) { index = index_point2; index_point2--; }\n\n                //Segundo triangulo\n                MyFile << \"i\" + to_string(index_point2) + \"\\n\";\n\n                string point3 = to_string(x) + \" \" + to_string(move_y) + \" \" + to_string(move_z - translation_w) + \"\\n\";\n                res = search_point(MyFile, m, point3, index);\n                if (res > index) index = res;\n\n                MyFile << \"i\" + to_string(index_point0) + \"\\n\";\n\n            }\n        }\n    }\n\n    MyFile.close();\n\n}\n\n\nint main(int argc, char const *argv[]) {\n\n  if (argc<2) {\n    cout << \"O número de argumentos é incorreto. \\n\\n\";\n\n  } else if (strcmp(argv[1], \"Plane\") == 0) {\n\n      if (argc == 5) {\n        float length = stof(argv[2]);\n        float width = stof(argv[3]);\n\n        if (length > 0.0f && width > 0.0f) {\n          create_plane(length,width,argv[4]);\n        }\n      }\n\n    } else if (strcmp(argv[1], \"Box\") == 0) {\n\n        if (argc==6 | argc==7) {\n          float length = stof(argv[2]);\n          float width = stof(argv[3]);\n          float height = stof(argv[4]);\n          int divisions = 1;\n\n          if (argc == 7) {\n            divisions = stoi(argv[5]);\n            if (length > 0.0f && width > 0.0f && height > 0.0f && divisions > 0) {\n                create_box(length, width, height, divisions, argv[6]);\n                /*\n                string point0 = to_string(0.2f) + \" \" + to_string(1.5f) + \" \" + to_string(0.7f) + \"\\n\";\n                string point1 = to_string(0.2f) + \" \" + to_string(1.5f) + \" \" + to_string(0.7f) + \"\\n\";\n                cout << to_string(point0.compare(point1)) + \"\\n\";\n                */\n\n            }\n          } else {\n            if (length > 0.0f && width > 0.0f && height > 0.0f && divisions > 0) {\n              create_box(length,width,height,divisions,argv[5]);\n\n            }\n          }\n        }\n      } else if (strcmp(argv[1], \"Sphere\") == 0) {\n      //do something\n\n    } else if (strcmp(argv[1], \"Cone\") == 0) {\n      //do something\n\n    } else {\n      cout << \"Primitiva desconhecida. \\n\\n\";\n    }\n  return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Generator/generator.cpp b/Generator/generator.cpp
--- a/Generator/generator.cpp	(revision d25c3731c2545a1f55093dc78f0cb3d905ecf0c1)
+++ b/Generator/generator.cpp	(date 1615593171413)
@@ -41,160 +41,6 @@
 }
 
 
-int search_point(ostream& file, map<string,int>& m, string point, int index) {
-  auto it = m.find(point);
-  if ( it == m.end() ) {
-    m.insert({point,index});
-    file << point;
-    return index+1; //retorna o valor de index incrementado para indicar que houve inserção no mapa
-
-  } else {
-    // found
-    file << "i" + to_string(it->second) + "\n";
-    return it->second; //retorna o valor de index que indica o indice em que estava o ponto
-  }
-
-}
-
-void create_box (float length, float width, float height, int divisions, string file_name) {
-    // Create and open a text file
-    ofstream MyFile(file_name);
-
-    // Write to the file
-    MyFile << "Box\n";
-    MyFile << to_string(6 * divisions * divisions * 6) + "\n"; //ns se esta bem
-
-    float translation_l = length / divisions;
-    float translation_w = width / divisions;
-    float translation_h = height / divisions;
-
-    map<string,int> m;
-
-    int index = 0;
-    std::cout.precision(std::numeric_limits<float>::digits10);
-
-    //Top and base
-    for (int k = 0; k < 2; k++) {
-        //Na primeira iteração y=height/2, para o topo, e na segunda y=-height/2, para a base.
-        float y = (height / 2) - (height * k);
-
-        for (int i = 0; i < divisions; i++) {
-            for (int j = 0; j < divisions; j++) {
-
-                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face
-                float move_x = (translation_l * j) + (-length / 2);
-                float move_z = (translation_w * i) + (-width / 2);
-                int index_point0;
-                int index_point2;
-
-                string point0 = to_string(move_x) + " " + to_string(y) + " " + to_string(move_z) + "\n";
-                index_point0 = search_point(MyFile, m, point0, index);
-                if (index_point0 > index) { index = index_point0; index_point0--; }
-
-                string point1 =to_string(move_x) + " " + to_string(y) + " " + to_string(translation_w + move_z) + "\n";
-                int res = search_point(MyFile,m,point1,index);
-                if (res > index) index = res;
-
-                string point2 = to_string(translation_l + move_x) + " " + to_string(y) + " " + to_string(translation_w + move_z) + "\n";
-                index_point2 = search_point(MyFile, m, point2, index);
-                if (index_point2 > index) { index = index_point2; index_point2--; }
-
-                //Segundo triangulo
-                MyFile << "i" + to_string(index_point2) + "\n";
-
-                string point3 = to_string(translation_l + move_x) + " " + to_string(y) + " " + to_string(move_z) + "\n";
-                res = search_point(MyFile, m, point3, index);
-                if (res > index) index = res;
-
-                MyFile << "i" + to_string(index_point0) + "\n";
-
-
-            }
-        }
-    }
-
-    //Front and back
-    for (int k = 0; k < 2; k++) {
-        //Na primeira iteração z=width/2, para a face da frente, e na segunda z=-width/2, para a face trás.
-        float z = (width / 2) - (width * k);
-
-        for (int i = 0; i < divisions; i++) {
-            for (int j = 0; j < divisions; j++) {
-                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face
-                float move_x = (translation_l * j) + (-length / 2);
-                float move_y = (height / 2) - (translation_h * i);
-                int index_point0;
-                int index_point2;
-
-                string point0 = to_string(move_x) + " " + to_string(move_y) + " " + to_string(z) + "\n";
-                index_point0 = search_point(MyFile, m, point0, index);
-                if (index_point0 > index) { index = index_point0; index_point0--; }
-
-                string point1 = to_string(move_x) + " " + to_string(move_y - translation_h) + " " + to_string(z) + "\n";
-                int res = search_point(MyFile,m,point1,index);
-                if (res > index) index = res;
-
-                string point2 = to_string(move_x + translation_l) + " " + to_string(move_y - translation_h) + " " + to_string(z) + "\n";
-                index_point2 = search_point(MyFile, m, point2, index);
-                if (index_point2 > index) { index = index_point2; index_point2--; }
-
-                //Segundo triangulo
-                MyFile << "i" + to_string(index_point2) + "\n";
-
-                string point3 = to_string(move_x + translation_l) + " " + to_string(move_y) + " " + to_string(z) + "\n";
-                res = search_point(MyFile, m, point3, index);
-                if (res > index) index = res;
-
-                MyFile << "i" + to_string(index_point0) + "\n";
-
-            }
-        }
-    }
-
-
-    //Right and left
-    for (int k = 0; k < 2; k++) {
-        //Na primeira iteração x=length/2, para a face da direita, e na segunda x=-length/2, para a face da esquerda.
-        float x = (length / 2) - (length * k);
-
-        for (int i = 0; i < divisions; i++) {
-            for (int j = 0; j < divisions; j++) {
-                //coordenadas do ponto de partida, às quais se aplicarão alterações para obter todos os outros pontos desta face
-                float move_y = (height / 2) - (translation_h * i);
-                float move_z = (width / 2) - (translation_w * j);
-                int index_point0;
-                int index_point2;
-
-                string point0 = to_string(x) + " " + to_string(move_y) + " " + to_string(move_z) + "\n";
-                index_point0 = search_point(MyFile, m, point0, index);
-                if (index_point0 > index) { index = index_point0; index_point0--; }
-
-                string point1 = to_string(x) + " " + to_string(move_y - translation_h) + " " + to_string(move_z) + "\n";
-                int res = search_point(MyFile,m,point1,index);
-                if (res > index) index = res;
-
-                string point2 = to_string(x) + " " + to_string(move_y - translation_h) + " " + to_string(move_z - translation_w) + "\n";
-                index_point2 = search_point(MyFile, m, point2, index);
-                if (index_point2 > index) { index = index_point2; index_point2--; }
-
-                //Segundo triangulo
-                MyFile << "i" + to_string(index_point2) + "\n";
-
-                string point3 = to_string(x) + " " + to_string(move_y) + " " + to_string(move_z - translation_w) + "\n";
-                res = search_point(MyFile, m, point3, index);
-                if (res > index) index = res;
-
-                MyFile << "i" + to_string(index_point0) + "\n";
-
-            }
-        }
-    }
-
-    MyFile.close();
-
-}
-
-
 int main(int argc, char const *argv[]) {
 
   if (argc<2) {
Index: Generator/cmake-build-debug/Testing/Temporary/LastTest.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Start testing: Mar 12 12:26 WET\n----------------------------------------------------------\nEnd testing: Mar 12 12:26 WET\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Generator/cmake-build-debug/Testing/Temporary/LastTest.log b/Generator/cmake-build-debug/Testing/Temporary/LastTest.log
--- a/Generator/cmake-build-debug/Testing/Temporary/LastTest.log	(revision d25c3731c2545a1f55093dc78f0cb3d905ecf0c1)
+++ b/Generator/cmake-build-debug/Testing/Temporary/LastTest.log	(date 1615593144873)
@@ -1,3 +1,3 @@
-Start testing: Mar 12 12:26 WET
+Start testing: Mar 12 23:52 WET
 ----------------------------------------------------------
-End testing: Mar 12 12:26 WET
+End testing: Mar 12 23:52 WET
